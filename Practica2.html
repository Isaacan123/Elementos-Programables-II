<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>Portafolio de Valeria e Isaac A.</title>
    <meta content="width=device-width, initial-scale=1.0" name="viewport">
    <meta content="Free HTML Templates" name="keywords">
    <meta content="Free HTML Templates" name="description">

    <!-- Favicon -->
    <link href="img/favicon.ico" rel="icon">

    <!-- Google Web Fonts -->
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700;900&display=swap" rel="stylesheet"> 

    <!-- Font Awesome -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.10.0/css/all.min.css" rel="stylesheet">

    <!-- Libraries Stylesheet -->
    <link href="lib/owlcarousel/assets/owl.carousel.min.css" rel="stylesheet">
    <link href="lib/lightbox/css/lightbox.min.css" rel="stylesheet">

    <!-- Customized Bootstrap Stylesheet -->
    <link href="css/style.css" rel="stylesheet">
</head>

<body data-spy="scroll" data-target=".navbar" data-offset="51">
    <!-- Navbar Start -->
    <nav class="navbar fixed-top shadow-sm navbar-expand-lg bg-light navbar-light py-3 py-lg-0 px-lg-5">
        <a href="index.html" class="navbar-brand ml-lg-3">
            <h1 class="m-0 display-5"><span class="text-primary">Aleman</span> y Huitrón</h1>
        </a>
        <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbarCollapse">
            <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse px-lg-3" id="navbarCollapse">
            <div class="navbar-nav m-auto py-0">
                <a href="#home" class="nav-item nav-link active">Inicio</a>
                <a href="#about" class="nav-item nav-link">Nosotros</a>
                <a href="#qualification" class="nav-item nav-link"></a>
                <a href="#skill" class="nav-item nav-link">Progreso</a>
                <a href="#blog" class="nav-item nav-link">Practicas</a>
                <a href="#service" class="nav-item nav-link">Contactame</a>
            </div>
            <a href="" class="btn btn-outline-primary d-none d-lg-block">Hire Me</a>
        </div>
    </nav>
    <!-- Navbar End -->


    <!-- Video Modal Start -->
    <div class="modal fade" id="videoModal" tabindex="-1" role="dialog" aria-labelledby="exampleModalLabel" aria-hidden="true">
        <div class="modal-dialog" role="document">
            <div class="modal-content">
                <div class="modal-body">
                    <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                        <span aria-hidden="true">&times;</span>
                    </button>        
                    <!-- 16:9 aspect ratio -->
                    <div class="embed-responsive embed-responsive-16by9">
                        <iframe class="embed-responsive-item" src="" id="video"  allowscriptaccess="always" allow="autoplay"></iframe>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <!-- Video Modal End -->


    <!-- Header Start -->
    <div class="container-fluid bg-primary d-flex align-items-center mb-5 py-5" id="home" style="min-height: 50;">
        <div class="container">
            <div class="row align-items-center">
                <div class="col-lg-5 px-1 pl-lg-2 pb-1 pb-lg-0">
                    <img class="img-fluid w-100 rounded-circle shadow-sm" src="img/FOTO1.jpg" alt="">
                </div>
                <div class="col-lg-7 text-center text-lg-left">
                    <h1 class="display-3 text-uppercase text-primary mb-2" style="-webkit-text-stroke: 1px #ffffff;">Practica 2:</h1>
                    <h1 class="typed-text-output d-inline font-weight-lighter text-white"></h1>
                    <div class="typed-text d-none">Attiny/ATmega328/ESP32 </div>
                    <div class="d-flex align-items-center justify-content-center justify-content-lg-start pt-5">
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    

    <!-- Qualification Start -->
    <div class="container-fluid py-5" id="qualification">
        <div class="container">
            <div class="position-relative d-flex align-items-center justify-content-center">
                <h5 class="display-3 text-uppercase text-white" style="-webkit-text-stroke: 1px #dee2e6;">Resumen</h5>
                <h1 class="position-absolute text-uppercase text-primary">Resumen</h1></div>
                <P>hemos explorado las capacidades de multitarea en diferentes microcontroladores: el ATtiny, el ATmega y el ESP32. Cada uno tiene sus limitaciones y características en cuanto a la gestión de tareas concurrentes, con el ATtiny y el ATmega utilizando técnicas de simulación de multitarea mediante interrupciones y multiplexación, <BR>
                    mientras que el ESP32 ofrece multitarea real gracias a su arquitectura de doble núcleo y el soporte de FreeRTOS.</P>
            </div>
            <div class="row align-items-center">
                <div class="col-lg-6">
                </div>
                                    <div class="container-fluid py-5" id="qualification">
                                        <div class="container">
                                            <div class="position-relative d-flex align-items-center justify-content-center">
                                                <h5 class="display-3 text-uppercase text-white" style="-webkit-text-stroke: 1px #dee2e6;">Introducción</h5>
                                                <h1 class="position-absolute text-uppercase text-primary">Introducción</h1>
                                            </div>
                                                </P><p>La velocidad de procesamiento de un microcontrolador determina su capacidad para ejecutar instrucciones y manejar tareas en tiempo real. Es fundamental en el diseño de sistemas embebidos, ya que influye en el rendimiento, la eficiencia energética y la compatibilidad con sensores y periféricos.
<br>
                                                    Un microcontrolador más rápido permite manejar cálculos complejos, responder rápidamente a eventos externos y ejecutar múltiples tareas simultáneamente. Sin embargo, un exceso de velocidad puede aumentar el consumo de energía y generar más calor, lo que es crítico en dispositivos portátiles o de bajo consumo.
                                                    <br>
                                                    Elegir la velocidad adecuada garantiza que el sistema funcione de manera óptima sin desperdiciar recursos, equilibrando potencia y eficiencia según la aplicación. 🚀
                                                    
                                                    
                                                    
                                                    
                                                    
                                                    
                                                    
                                                    </p>
                                                <!-- Header End -->
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Tabla de 4 Columnas con Estilos</title>
        <style>
            body {
                font-family: Arial, sans-serif;
                background-color: #f9f9f9;
                margin: 0;
                padding: 20px;
            }
            h1 {
                text-align: center;
                color: #333;
            }
            table {
                width: 80%;
                margin: 0 auto;
                border-collapse: collapse;
                box-shadow: 0 2px 5px rgba(0,0,0,0.1);
                background-color: #fff;
            }
            th, td {
                padding: 15px;
                border-bottom: 1px solid #ddd;
                text-align: center;
            }
            th {
                background-color: #dfebde;
                color: white;
            }
            tr:hover {
                background-color: #f1f1f1;
            }
            tr:nth-child(even) {
                background-color: #f9f9f9;
            }
        </style>
      <center>  <h3>Tabla comparativa</h3></center>
        <table>
            <tr>
                <th> </th>
                <th><b><a href="https://electrositio.com/que-es-un-microcontrolador-attiny85-y-como-funciona/" target="_blank"><b>Attiny</b>
                    <img src="img/microcontroladores/attiny.png" width="130px" alt="esp32"></th>
                <th><b><a href="https://www.programadornovato.com/esp32-que-es-y-para-que-sirve/" target="_blank"> ATTMega</a></b>
                    <br><img src="img/microcontroladores/atmega.png" width="130px" alt="esp32"></th>
                <th><b><a href="https://www.programadornovato.com/esp32-que-es-y-para-que-sirve/" target="_blank"> ESP32</a></b>
                    <br><img src="img/microcontroladores/ESP32.png" width="130px" alt="esp32"></th>

            <tr>
                <td><b>Memoria FLASH</b></td>
                <td>8 KB - 32 KB</td>
                <td>8 KB - 256 KB</td>
                <td>4 MB (varía)</td>
            </tr>
            <tr>
                <td><b>Memoria RAM</b></td>
                <td>6 - 23</td>
                <td>23 - 54</td>
                <td>34 - 48</td>
            </tr>
            <tr>
                <td><b>UART</b></td>
                <td>1 - 2	</td>
                <td>1 - 4</td>
                <td>2 - 3</td>
            </tr>
        </table>
    <!-- Header End --><br>


     <br>

    <div class="container-fluid py-5" id="qualification">
        <div class="container">
            <div class="position-relative d-flex align-items-center justify-content-center">
                <h5 class="display-3 text-uppercase text-white" style="-webkit-text-stroke: 1px #dee2e6;">Materiales</h5>
                <h1 class="position-absolute text-uppercase text-primary">Materiales</h1>
            </div>
    <table>
     <p></p>
        <tr>
            <td>ESP3232C6</td>
        </tr>
        <tr>
            <td>Arduino</td>
        </tr>
        <tr>
            <td>Attiny</td>
        </tr>
      
    </table>
    <div class="container-fluid py-5" id="qualification">
        <div class="container">
            <div class="position-relative d-flex align-items-center justify-content-center">
                <h5 class="display-3 text-uppercase text-white" style="-webkit-text-stroke: 1px #dee2e6;">Desarrollo</h5>
                <h1 class="position-absolute text-uppercase text-primary">Desarrollo</h1>
            </div>
         </div>
         <p><strong>ATtiny:</strong> Al ser un microcontrolador de 8 bits, el ATtiny no soporta multitarea real. Sin embargo, puede simular multitarea utilizando interrupciones y técnicas como la multiplexación de tareas. Estas técnicas permiten que el ATtiny gestione varias tareas de manera secuencial pero eficiente, aunque no de forma paralela.</p>

<p><strong>ATmega:</strong> Similar al ATtiny, el ATmega no tiene soporte para multitarea nativa. No obstante, con el uso de interrupciones y multiplexación, es posible simular una multitarea, alternando rápidamente entre tareas, lo que da la impresión de que varias tareas se ejecutan simultáneamente.</p>

<p><strong>ESP32:</strong> El ESP32 es mucho más avanzado y permite multitarea real. Con su arquitectura de doble núcleo, el ESP32 puede ejecutar tareas en paralelo. Gracias a FreeRTOS, este microcontrolador gestiona hilos (tasks) de forma eficiente, permitiendo que diversas tareas se ejecuten simultáneamente, mejorando el rendimiento y la capacidad de respuesta en aplicaciones más complejas.</p>
         <div class="container-fluid py-5" id="qualification">
            <div class="container">
                <div class="position-relative d-flex align-items-center justify-content-center">
                    <h5 class="display-3 text-uppercase text-white" style="-webkit-text-stroke: 1px #e69b69;">ATTINY</h5>
                    <h1 class="position-absolute text-uppercase text-primary">ATTINY</h1>
                </div></div>
                <p>La velocidad del ATtiny varía según el modelo y el tipo de oscilador utilizado. Por defecto, su reloj interno funciona a 1 MHz, pero puede configurarse hasta 8 MHz sin necesidad de un cristal externo.
                    <br>
                                Si se utiliza un reloj externo, como un cristal o un resonador cerámico, la frecuencia puede alcanzar hasta 20 MHz en la mayoría de los modelos.</p>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tabla de Velocidad ATtiny</title>
   
</head>
    <table>
        <thead>
            <tr>
                <th>Modelo</th>
                <th>Velocidad máxima (MHz)</th>
                <th>Flash (KB)</th>
                <th>RAM (Bytes)</th>
                <th>GPIO</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>ATtiny85</td>
                <td>20 MHz</td>
                <td>8 KB</td>
                <td>512</td>
                <td>6</td>
            </tr>
            <tr>
                <td>ATtiny84</td>
                <td>20 MHz</td>
                <td>8 KB</td>
                <td>512</td>
                <td>12</td>
            </tr>
            <tr>
                <td>ATtiny13</td>
                <td>20 MHz</td>
                <td>1 KB</td>
                <td>64</td>
                <td>5</td>
            </tr>
        </tbody>
    </table>
    <br>
    <center><h3>Flash</h3></center>
    <p>Es la memoria principal donde se almacena el programa. Es no volátil, por lo que conserva los datos tras apagarse.</p>
    <p><strong>Ejemplo:</strong> Si grabas un código en un ATtiny85, este permanecerá allí incluso después de desconectarlo de la corriente.</p>
    <p><strong>Capacidad:</strong> Entre 1 KB y 8 KB, según el modelo.</p>
    <br>
    <center><h3>RAM</h3></center>
    <p>Se usa para almacenar variables y datos temporales durante la ejecución. Es volátil, por lo que su contenido se pierde al reiniciar el sistema.</p>
    <p><strong>Ejemplo:</strong> Si una variable almacena el número de veces que presionas un botón, este dato se perderá al apagar el microcontrolador.</p>
    <p><strong>Capacidad:</strong> Entre 64 y 512 Bytes.</p>
<BR>
    <title>Comparativa entre UART y Serial</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f4f4f9;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        th, td {
            padding: 8px;
            text-align: left;
            border: 1px solid #ddd;
        }
        th {
            background-color: #dedede;
        }
        tr:nth-child(even) {
            background-color: #ffffff;
        }
    </style>
</head>
<body>
<center> <h3>Comparativa entre UART y Serial</h3></center>
    <table>
        <thead>
            <tr>
                <th>Característica</th>
                <th>UART</th>
                <th>Serial</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Definición</td>
                <td>Protocolo de comunicación en serie asíncrona que usa dos líneas: TX (transmisión) y RX (recepción).</td>
                <td>Término genérico que refiere a la transmisión de datos bit a bit a través de un solo canal, usando protocolos como UART.</td>
            </tr>
            <tr>
                <td>Tipo de Comunicación</td>
                <td>Asíncrona (sin necesidad de reloj externo, usa tasa de baudios compartida).</td>
                <td>Comunicación serie en general, que puede usar diversos protocolos como UART, SPI o I2C.</td>
            </tr>
            <tr>
                <td>Líneas de Comunicación</td>
                <td>TX y RX (Transmisión y Recepción).</td>
                <td>Generalmente usa UART para transmisión, pero también puede incluir otros tipos de comunicación en serie.</td>
            </tr>
            <tr>
                <td>Configuración</td>
                <td>Flexible, permite ajustar tamaño de datos, paridad y bits de parada.</td>
                <td>Varía según el protocolo utilizado; UART es uno de los más comunes.</td>
            </tr>
            <tr>
                <td>Uso</td>
                <td>Comúnmente utilizado para comunicación entre microcontroladores y dispositivos como módulos GPS, Bluetooth, etc.</td>
                <td>Usado generalmente para depuración, programación o transmisión de datos entre dispositivos.</td>
            </tr>
        </tbody>
    </table>
    <br>
   <center><h3>Multitarea<br>
        (Hilos)</h3></center> 
    <p>El ATtiny no tiene soporte nativo para multitarea con hilos paralelos, pero puede simularla mediante métodos de software como interrupciones y multiplexación de tareas. Usando interrupciones, el microcontrolador puede pausar una tarea en curso para atender eventos importantes, como cambios en sensores o pines, y luego reanudarla. Además, con técnicas como la multiplexación de tareas, se puede alternar entre diferentes tareas en ciclos rápidos, lo que da la sensación de que se están ejecutando simultáneamente, aunque el ATtiny ejecuta solo una tarea a la vez.</p>
         <div class="container-fluid py-5" id="qualification">
        <div class="container">
            <div class="position-relative d-flex align-items-center justify-content-center">
                <h5 class="display-3 text-uppercase text-white" style="-webkit-text-stroke: 1px #9dccfb;">ATmega</h5>
                <h1 class="position-absolute text-uppercase text-primary">ATmega</h1>
            </div>
         <P>La familia de microcontroladores ATmega, fabricada por Microchip Technology, pertenece a la arquitectura AVR de 8 bits y es más potente que los ATtiny, siendo utilizada en proyectos complejos como Arduino.  

            Su velocidad de procesamiento varía según el modelo y el tipo de oscilador utilizado. Con reloj interno, funcionan por defecto a 1 MHz, pero pueden alcanzar hasta 8 MHz sin cristal externo. Con reloj externo, la mayoría de los modelos soportan cristales de hasta 20 MHz.</P>
            <table>
                <thead>
                    <tr>
                        <th>Modelo</th>
                        <th>Velocidad máxima (MHz)</th>
                        <th>Flash (KB)</th>
                        <th>RAM (Bytes)</th>
                        <th>GPIO</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>ATmega328P</td>
                        <td>20 MHz</td>
                        <td>32 KB</td>
                        <td>2 KB</td>
                        <td>23</td>
                    </tr>
                    <tr>
                        <td>ATmega32U4</td>
                        <td>16 MHz</td>
                        <td>32 KB</td>
                        <td>2.5 KB</td>
                        <td>26</td>
                    </tr>
                    <tr>
                        <td>ATmega2560</td>
                        <td>16 MHz</td>
                        <td>256 KB</td>
                        <td>8 KB</td>
                        <td>86</td>
                    </tr>
                </tbody>
            </table>
     <br>
            <center>  <h3>Memoria Flash <br>(Almacenamiento del Programa)</h3></center>
    <p><strong>Tipo:</strong> No volátil, lo que significa que conserva los datos incluso cuando se apaga el microcontrolador.</p>
    <p><strong>Uso:</strong> Almacena el código del programa que ejecuta el microcontrolador.</p>
    <p><strong>Capacidad:</strong> Varía dependiendo del modelo, generalmente entre 8 KB y 256 KB. El ATmega328P, por ejemplo, tiene 32 KB de Flash.</p>
    <p><strong>Ejemplo:</strong> Imagina que estás programando un sistema de control para una lámpara inteligente. El código que controla la encendida y apagada de la lámpara se almacenaría en la Flash.</p>
    <h4>Características:</h4>
    <ul>
        <li>La Flash es más lenta para escribir, pero retiene la información incluso cuando se apaga el microcontrolador.</li>
        <li>La cantidad de ciclos de escritura es limitada (aproximadamente 10,000 veces), por lo que debe evitarse reescribir datos constantemente.</li>
        <li>Es la memoria principal para el código que debe ejecutarse al arrancar el microcontrolador.</li>
        <li>Si tu proyecto crece en complejidad, es importante optimizar el tamaño del código para dejar suficiente espacio libre.</li>
    </ul>

    <center>  <h3>Memoria RAM (Datos Volátiles)</h3></center>
    <p><strong>Tipo:</strong> Volátil, lo que significa que se pierde al apagar o reiniciar el microcontrolador.</p>
    <p><strong>Uso:</strong> Almacena las variables y datos temporales durante la ejecución del programa.</p>
    <p><strong>Capacidad:</strong> Generalmente varía entre 1 KB y 8 KB, dependiendo del modelo. El ATmega328P tiene 2 KB de RAM.</p>
    <p><strong>Ejemplo:</strong> Si estás programando un sistema que mide la temperatura con un sensor, la temperatura leída se almacena en la RAM para que puedas procesarla o mostrarla en una pantalla LCD.</p>
    <h4>Características:</h4>
    <ul>
        <li>La RAM permite un acceso rápido a los datos mientras el microcontrolador está funcionando, pero su contenido se pierde al apagar el dispositivo.</li>
        <li>Si no se optimiza bien, el uso excesivo de la RAM puede causar desbordamientos de pila o afectar el rendimiento general.</li>
        <li>Para proyectos pequeños, como el control de un sensor de humedad, la RAM del ATmega328P puede ser suficiente, pero en sistemas más grandes, la falta de memoria RAM puede generar problemas.</li>
    </ul>
    <center>  <h3>Comparativa entre UART y Serial del ATmega</h3></center>
    <table>
        <thead>
            <tr>
                <th>Característica</th>
                <th>UART</th>
                <th>Serial</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Definición</td>
                <td>Protocolo de comunicación serie asíncrona que usa dos pines: TX (Transmisión) y RX (Recepción), sin necesidad de reloj externo.</td>
                <td>Término genérico que se refiere a cualquier comunicación en serie, pero en este caso, generalmente hace referencia a UART.</td>
            </tr>
            <tr>
                <td>Tipo de Comunicación</td>
                <td>Asíncrona, no requiere señal de reloj externa, sincroniza la transmisión con la tasa de baudios.</td>
                <td>Generalmente hace referencia a la comunicación UART, que es una forma asíncrona de comunicación en serie.</td>
            </tr>
            <tr>
                <td>Líneas de Comunicación</td>
                <td>TX (Transmisión) y RX (Recepción).</td>
                <td>Usa generalmente las líneas TX y RX de UART, aunque puede referirse a otros protocolos de comunicación en serie.</td>
            </tr>
            <tr>
                <td>Configuración</td>
                <td>Flexible: tamaño de datos, paridad y bits de parada ajustables.</td>
                <td>La configuración puede ser similar a la de UART si se refiere a este protocolo, pero puede incluir otros protocolos de comunicación.</td>
            </tr>
            <tr>
                <td>Uso Común</td>
                <td>Comunicaciones entre microcontroladores y dispositivos como sensores, módulos Bluetooth, GPS, etc.</td>
                <td>Se utiliza principalmente para depuración y comunicación entre dispositivos, común en plataformas como Arduino.</td>
            </tr>
        </tbody>
    </table>  
    <br>
<center><h3>Multitarea<br>
        (Hilos)</h3></center>
<P>El ATmega, al ser un microcontrolador de 8 bits, no soporta multitarea con hilos paralelos de manera nativa. Sin embargo, es posible simular multitarea utilizando interrupciones y multiplexación. Las interrupciones permiten que el ATmega responda a eventos sin interrumpir otras tareas en curso, mientras que la multiplexación de tareas, mediante temporizadores o ciclos de tiempo, permite alternar entre diferentes tareas rápidamente, dando la sensación de ejecución simultánea. <BR>
    Aunque no hay multitarea real, estas técnicas permiten gestionar múltiples tareas de manera eficiente.</P>
    <!-- Blog Start -->
    <div class="container-fluid py-5" id="qualification">
        <div class="container">

            <div class="position-relative d-flex align-items-center justify-content-center">
                <h5 class="display-3 text-uppercase text-white" style="-webkit-text-stroke: 1px #f83939;">ESP32</h5>
                <h1 class="position-absolute text-uppercase text-primary">ESP32</h1>
            </div>
        <P>El ESP32, desarrollado por Espressif Systems, es un microcontrolador de 32 bits con uno o dos núcleos, diseñado para aplicaciones de IoT y redes inalámbricas. Su CPU opera entre 160 y 240 MHz, con modelos optimizados para ahorro energético a 150 MHz.

            Cuenta con memoria Flash externa (4 MB o más) y 320 KB de SRAM interna, ampliable con 8 MB adicionales. Además, integra un coprocesador de bajo consumo (ULP) para ejecutar tareas como la lectura de sensores sin activar el núcleo principal, optimizando la eficiencia energética.</P>
            <table>
                <thead>
                    <tr>
                        <th>Modelo</th>
                        <th>CPU</th>
                        <th>Velocidad (MHz)</th>
                        <th>Flash (MB)</th>
                        <th>RAM (KB)</th>
                        <th>GPIO</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>ESP32-WROOM-32</td>
                        <td>Dual-core</td>
                        <td>240 MHz</td>
                        <td>4 MB</td>
                        <td>520 KB</td>
                        <td>34</td>
                    </tr>
                    <tr>
                        <td>ESP32-S2</td>
                        <td>Single-core</td>
                        <td>240 MHz</td>
                        <td>4 MB</td>
                        <td>320 KB</td>
                        <td>43</td>
                    </tr>
                    <tr>
                        <td>ESP32-S3</td>
                        <td>Dual-core</td>
                        <td>240 MHz</td>
                        <td>16 MB</td>
                        <td>512 KB</td>
                        <td>44</td>
                    </tr>
                    <tr>
                        <td>ESP32-C3</td>
                        <td>Single-core (RISC-V)</td>
                        <td>160 MHz</td>
                        <td>4 MB</td>
                        <td>400 KB</td>
                        <td>22</td>
                    </tr>
                </tbody>
            </table>
            <div class="section">
                <br>
                <center><h2>Memoria Flash</h2></center>
                <p><strong>Tipo:</strong> No volátil, mantiene la información incluso cuando el dispositivo está apagado.</p>
                <p><strong>Uso:</strong> Almacena el firmware (código del programa), configuraciones persistentes y otros archivos que deben permanecer entre reinicios.</p>
                <p><strong>Capacidad:</strong> Varía entre 4 MB y 16 MB, dependiendo del modelo de ESP32. Las versiones más comunes suelen tener entre 4 MB y 8 MB de Flash.</p>
                <p><strong>Características:</strong></p>
                <ul>
                    <li><strong>Lectura rápida:</strong> Ideal para cargar y ejecutar el programa desde la memoria Flash.</li>
                    <li><strong>Escritura más lenta:</strong> La Flash tiene un número limitado de ciclos de escritura (aproximadamente 100,000 a 1,000,000 de escrituras).</li>
                </ul>
                <div class="example">
                    <p><strong>Ejemplo:</strong> En un proyecto como una estación meteorológica con Wi-Fi, el código para leer los sensores y enviar los datos a la nube se almacena en la Flash. También puedes guardar configuraciones como las credenciales Wi-Fi para que se carguen automáticamente cada vez que el dispositivo se reinicie.</p>
                </div>
            </div>
        
            <div class="section">
                <br>
                <center> <h2>Memoria RAM</h2></center>
                <p><strong>Tipo:</strong> Volátil, pierde toda la información cuando se apaga el microcontrolador.</p>
                <p><strong>Uso:</strong> Se utiliza para almacenar datos temporales durante la ejecución del programa, como variables, buffers, pilas y estructuras de datos en tiempo real.</p>
                <p><strong>Capacidad:</strong> El ESP32 tiene 512 KB de RAM en total, con aproximadamente 320 KB dedicados a almacenamiento de datos y 160 KB reservados para caché de acceso rápido.</p>
                <p><strong>Características:</strong></p>
                <ul>
                    <li><strong>Acceso rápido:</strong> Crucial para la ejecución en tiempo real de tareas que requieren procesamiento inmediato.</li>
                    <li><strong>Gestión eficiente:</strong> Es importante optimizar el uso de la RAM para evitar desbordamientos o saturación, ya que la memoria es limitada.</li>
                </ul>
                <div class="example">
                    <p><strong>Ejemplo:</strong> Si tienes un sistema de monitoreo de sensores de temperatura y humedad, la RAM almacena las lecturas de los sensores antes de procesarlas o mostrarlas en una pantalla LCD. Una vez procesados, los resultados pueden ser enviados a la Flash o a un servidor.</p>
                </div>
            </div>
            <table>
                <thead>
                    <tr>
                        <th>Memoria</th>
                        <th>Tipo</th>
                        <th>Capacidad típica</th>
                        <th>Uso principal</th>
                        <th>Características</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Flash</td>
                        <td>No volátil</td>
                        <td>4 MB a 16 MB</td>
                        <td>Almacena el código del programa, configuraciones, archivos.</td>
                        <td>Rápido para lectura, más lento para escritura, limitado en ciclos de escritura.</td>
                    </tr>
                    <tr>
                        <td>RAM</td>
                        <td>Volátil</td>
                        <td>512 KB</td>
                        <td>Almacena datos temporales durante la ejecución del programa.</td>
                        <td>Acceso rápido a datos en tiempo real, gestión eficiente importante para evitar errores de memoria.</td>
                    </tr>
                </tbody>
            </table>
            <br>
          <center><h3>Comparativa entre UART y Serial del ESP32</h3> </center>
            <table>
                <thead>
                    <tr>
                        <th>Característica</th>
                        <th>UART</th>
                        <th>Serial</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Definición</td>
                        <td>Protocolo de comunicación asíncrona que utiliza los pines TX y RX para la transmisión y recepción de datos sin necesidad de un reloj externo.</td>
                        <td>Término que generalmente se refiere a la interfaz UART del ESP32, utilizada para la comunicación serial, programación y depuración.</td>
                    </tr>
                    <tr>
                        <td>Tipo de Comunicación</td>
                        <td>Asíncrona, no requiere señal de reloj externa, se sincroniza por la tasa de baudios.</td>
                        <td>Generalmente hace referencia a la interfaz UART para la transmisión de datos en serie, aunque puede incluir otros métodos.</td>
                    </tr>
                    <tr>
                        <td>Líneas de Comunicación</td>
                        <td>TX (Transmisión) y RX (Recepción).</td>
                        <td>Usa los mismos pines TX y RX, pero en un contexto más amplio de comunicación serial.</td>
                    </tr>
                    <tr>
                        <td>Configuración</td>
                        <td>Permite ajustar parámetros como la tasa de baudios, el tamaño de los datos, la paridad y los bits de parada.</td>
                        <td>Similar a la configuración de UART, pero se refiere al uso general de la comunicación serial en el ESP32.</td>
                    </tr>
                    <tr>
                        <td>Soporte para Múltiples Interfaces</td>
                        <td>Hasta 3 interfaces UART (UART0, UART1, UART2), permitiendo múltiples conexiones.</td>
                        <td>El término "Serial" engloba las distintas interfaces UART, permitiendo múltiples conexiones seriales.</td>
                    </tr>
                    <tr>
                        <td>Velocidad de Comunicación</td>
                        <td>Hasta 5 Mbps.</td>
                        <td>Hasta 5 Mbps, ya que generalmente utiliza UART para la comunicación serial.</td>
                    </tr>
                    <tr>
                        <td>Uso Común</td>
                        <td>Comunicación con dispositivos como sensores, módulos Bluetooth, y otros periféricos.</td>
                        <td>Comúnmente utilizado para la programación, depuración y comunicación de datos entre el ESP32 y otros dispositivos.</td>
                    </tr>
                </tbody>
            </table>
            <center><h3>Multitarea<br>
                (Hilos)</h3> </center>
                <P>El ESP32, gracias a su arquitectura de doble núcleo y el sistema operativo FreeRTOS,<BR>
                     permite realizar multitarea real. Con dos núcleos, puede ejecutar tareas en paralelo, distribuyendo el trabajo entre ambos. FreeRTOS facilita la gestión de hilos, permitiendo que múltiples tareas se ejecuten simultáneamente, mejorando la eficiencia y el rendimiento en aplicaciones complejas.</P>
    <!-- Blog End -->
    <!-- Blog End -->
    <div class="container-fluid py-5" id="qualification">
        <div class="container">
            <div class="position-relative d-flex align-items-center justify-content-center">
                <h5 class="display-3 text-uppercase text-white" style="-webkit-text-stroke: 1px #dee2e6;">Conclusion</h5>
                <h1 class="position-absolute text-uppercase text-primary">Conclusion</h1>
            </div>
              <P>El ATtiny y el ATmega simulan multitarea mediante técnicas como interrupciones y multiplexación, mientras que el ESP32 soporta multitarea real gracias a su doble núcleo y FreeRTOS, ofreciendo una mayor eficiencia en la gestión de tareas concurrentes.</P>
        
          
   
  


    <!-- Footer Start -->
    <div class="container-fluid bg-primary text-white mt-5 py-5 px-sm-3 px-md-5">
        <div class="container text-center py-5">
            <div class="d-flex justify-content-center mb-4">
                <a class="btn btn-light btn-social mr-2" href="#"><i class="fab fa-twitter"></i></a>
                <a class="btn btn-light btn-social mr-2" href="#"><i class="fab fa-facebook-f"></i></a>
                <a class="btn btn-light btn-social mr-2" href="#"><i class="fab fa-linkedin-in"></i></a>
                <a class="btn btn-light btn-social" href="#"><i class="fab fa-instagram"></i></a>
            </div>
            <div class="d-flex justify-content-center mb-3">
                <a class="text-white" href="#">Privacy</a>
                <span class="px-3">|</span>
                <a class="text-white" href="#">Terms</a>
                <span class="px-3">|</span>
                <a class="text-white" href="#">FAQs</a>
                <span class="px-3">|</span>
                <a class="text-white" href="#">Help</a>
            </div>
            <p class="m-0">&copy; <a class="text-white font-weight-bold" href="#">Aleman</a>. All Rights Reserved. 
    </div>
    <!-- Footer End -->

    <!-- Scroll to Bottom -->
    <i class="fa fa-2x fa-angle-down text-white scroll-to-bottom"></i>

    <!-- Back to Top -->
    <a href="#" class="btn btn-outline-dark px-0 back-to-top"><i class="fa fa-angle-double-up"></i></a>


    <!-- JavaScript Libraries -->
    <script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.bundle.min.js"></script>
    <script src="lib/typed/typed.min.js"></script>
    <script src="lib/easing/easing.min.js"></script>
    <script src="lib/waypoints/waypoints.min.js"></script>
    <script src="lib/owlcarousel/owl.carousel.min.js"></script>
    <script src="lib/isotope/isotope.pkgd.min.js"></script>
    <script src="lib/lightbox/js/lightbox.min.js"></script>

    <!-- Contact Javascript File -->
    <script src="mail/jqBootstrapValidation.min.js"></script>
    <script src="mail/contact.js"></script>

    <!-- Template Javascript -->
    <script src="js/main.js"></script>
</body>

</html>